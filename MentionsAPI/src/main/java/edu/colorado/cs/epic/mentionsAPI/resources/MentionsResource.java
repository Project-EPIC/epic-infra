package edu.colorado.cs.epic.mentionsAPI.resources;

import com.google.api.gax.paging.Page;
import com.google.cloud.storage.*;

import javax.validation.constraints.Max;
import javax.validation.constraints.Min;
import javax.validation.constraints.Null;
import javax.ws.rs.*;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

import io.dropwizard.jersey.params.IntParam;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.log4j.Logger;
import org.json.simple.JSONObject;

import java.util.concurrent.atomic.AtomicLong;


@Path("/mentions/")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class MentionsResource {
    private final Logger logger;
    private final AtomicLong counter;

    // Name of the bucket we are accessing
    String BUCKET_URL = "epic-analysis-results";
    // Starting name of the json files generated by Spark
    String part = "part-";

    // Get Google Cloud Storage Service
    Storage gStorage = StorageOptions.getDefaultInstance().getService();
    // Load the spark folder inside our bucket
    Blob aux = gStorage.get(BUCKET_URL, "spark");

    Page<Blob> blobs;

    public MentionsResource(Bucket storage){
        this.logger = Logger.getLogger(MentionsResource.class.getName());
        this.counter = new AtomicLong();

        // Generate a list of the blobs inside the bucket
        blobs = storage.list();
    }


    @GET
    @Path("/{eventName}/")
    public String getMentionsFromEvent(@PathParam("eventName") String eventName,
                                       @QueryParam("page") @DefaultValue("1") @Min(1) IntParam page,
                                       @QueryParam("count") @DefaultValue("100") @Min(1) @Max(1000) IntParam pageCount) {

        // Number of pages we want to show
        int pageNumber = page.get();
        // Size of the pages
        int pageSize = pageCount.get();

        int startIndex = (pageNumber - 1) * pageSize;
        int endIndex = startIndex + pageSize;
        int auxCounter = 0;

        // Blob path including the event name
        String filePath = "spark/mentions/" + eventName + "/20";

        // Iterate through all the blobs inside "epic-analysis-results/spark"
        for (Blob blob : blobs.iterateAll()) {
            // Identify our Spark JSON file by using the file path and making sure it contains the word "part-"
            if (blob.getName().contains(part) && blob.getName().contains(filePath)) {
                // Store the file in an aux variable
                aux = blob;
                auxCounter = 1;
            }
        }

        // Error case no event is found
        if(auxCounter == 0){
            throw new WebApplicationException(Response.Status.NOT_FOUND);
        }

        // Store the content of the JSON file
        String fileContent = new String(aux.getContent());

        // Separate each JSON object per line in the file
        String lines[] = fileContent.split("\\r?\\n");

        // Error case: if page/size of the page requested is out of bounds
        if((lines.length - (pageNumber * pageSize)) < 0 ){
            throw new WebApplicationException(Response.Status.BAD_REQUEST);
        }

        // Create the String that we will return
        StringBuilder tweets = new StringBuilder();
        // Format to proper JSON
        tweets.append("{\"mentions\":[");

        // Access the page we want to return
        for(int i = startIndex; i < endIndex; i++){
            // Append the lines to our final String
            tweets.append(lines[i]);
            // Separate each user by a comma
            tweets.append(",");
        }

        // Remove last comma
        if (tweets.length() > 0) {
            tweets.setLength(tweets.length() - 1);
        }

        // Close our user tweets
        tweets.append("],");

        // Store some additional information

        JSONObject metaObject = new JSONObject();
        metaObject.put("count", pageSize);
        metaObject.put("page", pageNumber);
        metaObject.put("event_name", eventName);
        //metaObject.put("refreshed_time", updateTime.toString());

        // End the JSON formatting
        tweets.append("\"meta\":");
        tweets.append(metaObject.toJSONString());
        tweets.append("}");

        // Return the JSON string to the request
        return tweets.toString();

    }
}